>>HTTP 1.1的新特性

>持久连接
在HTTP 1.1之前，无论浏览器何时连接到Web服务器，当服务器将请求的资源返回后，就会断开与浏览器的连接。但是，网页上会包含一些其他资源，如图片文件、叩plet等。因此，当请求一个页面时，浏览器还需要下载这些被页面引用的资源。如果页面和它引用的所有资源文件都使用不同的连接进行下载的话，处理过程会很慢。这就是为什么HTTP 1.1中会引人持久连接。使用持久连接后，当下载了页面后·服务器并不会立即关闭连接。相反，它会等待Web客户端请求被该页面所引用的所有资源，这样一来，页面和被页面引用的资源都会使用同一个连接来下载。考虑到建立/关闭HTTP连接是一个系统开销很大的操作，使用同一个连接来下载所有的资源会为Web服务器、客户端和网络节省很多时间和工作量。
在HTTP 1.1中，会默认使用持久连接。当然，也可以显式地使用，方法是浏览器发送如下的请求头信息：
connection: keep-alive

>块编码
建立了持久连接后，服务器可以从多个资源发送字节流，而客户端也可以使用该连接发送多个请求。这样的结果就是发送方必须在每个请求或响应中添加"content-length ”头信息，这样，接收方才能知道如何解释这些字节信息。但通常情况下，发送方并不知道要发送多少字节。例如，servlet容器可能要在接收到一些字节之后，就开始发送响应信息，而不必等到接收完所有的信息。这就是说，必须有一种方法来告诉接收方在不知道发送内容长度的情况下，如何解忻已经接收到的内容。
其实，即使没有发出多个请求或发送多个响应，服务器或客户端也不需要知道有多少字节要发送。在HTTP 1.0中，服务器可以不写"content-length ”头信息，尽管往连接中写响应内容就行了。当发送完响应信息后，它就直接关闭连接。在这种情况下，客户端会一直读取内容，直到读方法返回—l,这表明已经读到了文件宋尾。
HTTP 1.1使用一个名为"transfer-encoding ”的特殊请求头，来指明字节流将会分块发送。对每一个块，块的长度（以十六进制表示）后面会有一个回车/换行符(CR/LF),然后是具体
数据。一个事务以一个长度为0的块标记。假设要用两个块发送下面38个字节的内容，其中第1个块为29个字节，第2个块为9个字节：
了，m s he 1 p 1 e s s a s a k i t t e n up a t r e e．
那么，实际上应该发送如下内容：
ID\r\n 了，m a s he 1 p 1 e g s a s & ki t t en u
p a匕r e e．
O \ r \ n
" ID ”的十进制表示是29，表明第1个块的长度是29个字节，“ 0 ”表明事务已经完成。

>状态码100的使用
使用HTTP 1.1的客户端可以在向服务器发送请求体之前发送如下的请求头，并等待服务器的确认：
Expect: 100．00n匕inue
当客户端准备发送一个较长的请求体，而不确定服务端是否会接收时，就可能会发送上面的头信息。若是客户端发送了较长的请求体，却发现服务器拒绝接收时，会是较大的浪费。
接收到"Expect: 100-continue ”请求头后，若服务器可以接收并处理该请求时，可以发送如下的响应头：
HTTP/I、1 100 Continue
注意，返回内容后面要加上CRLF字符。
然后，服务器继续读取输人流的内容。